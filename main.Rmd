---
title: "Consequences of severe weather events on population health and economy in US"
subtitle: "Analysis based on data from the National Oceanic and Atmospheric Administration's Storm Database"
author: "David Affagard"
date: "May, 2019"
year: "2019"
output: 
        html_document:
                toc: TRUE
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
[Git repo : https://github.com/affagard/RepData_PeerAssessment2/](https://github.com/affagard/RepData_PeerAssessment2/)
\  
\  

## Synopsis
The basic goal of this assignment is to explore U.S. National Oceanic and Atmospheric Administration (NOAA)'s Storm Database in order to answer the following questions about severe weather events :

 * First, across the United States, which types of events are most harmful with respect to population health?
 * And finally, which types of events have the greatest economic consequences?
 
Initially the the data source needs cleaning : the big job is first to standardize the types of events and secondly to merge the similar events from point of view of the population and the damage, instead of the meteorological scientist point of view.

The data analysis leads us :

 - to select a significant period in time for the analysis
 - to plot histograms showing the most harmful event types globally in the US detailing fatalities and injuries and showing, across the U.S., the most affected states for the most harmful event types
 - to plot a histogram showing damage costs of each event types, detailing crop and property damages
 
\  

```{r Libraries, message=FALSE}
# Required libraries
library(knitr)
library(lubridate)
library(R.cache)
library(stringr)
library(dplyr)
library(data.table)
library(ggplot2)
```
\  

## Data processing
Loading and preprocessing the data

- Dataset : Storm Data, an official publication from the National Weather Service of the National Oceanic & Atmospheric Administration. 
- Data source URL may be dowloaded [here [47Mb]](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2)
\  
```{r Data loading, message=FALSE, warning=FALSE}

        if(!file.exists("data/StormData.csv.bz2")) {
                
                if(!dir.exists("data")) {
                        dir.create("data", showWarnings = TRUE, recursive = FALSE, mode = "0744")
                }
                
                download.file(
                        "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2",
                        destfile = "data/StormData.csv.bz2",
                        method = "curl"
                )
                
        }

        # Cache loading : if read data are already stored in cache, we take data in cache

        bypass_cache <- FALSE # Set to TRUE if you want to force reading from the CSV file
        
        if (bypass_cache | is.null(storm_data <- loadCache(list("read_storm_data")))) {
                storm_data <- read.csv ("data/StormData.csv.bz2", header=TRUE, sep = ",", dec=".")
                storm_data$EVTYPE <- trimws(toupper(storm_data$EVTYPE))
                storm_data$STATE <- trimws(toupper(storm_data$STATE))
                saveCache(storm_data, key=list("read_storm_data"))
        }
```
\  
\  

### Get state fullnames
State names are defined in a specific CSV file `UNITED_STATES.csv`, dowloadable here
```{r Read United States names}
united_states <- read.csv ("data/UNITED_STATES.csv", header=TRUE, sep = ",")
storm_data <- merge(storm_data, united_states, by = "STATE", all.x = TRUE)
```
\  
\  

### Informations about dataset (`storm_data`)
 - `r dim(storm_data)[1]` records, each of 37 columns
 - Columns that will be used for this study
 
        - REFNUM : a unique reference to each record
        - STATE : In 2 letters, the american state in which the event is located 
        - STATENAME : Fullname of STATE  
        - EVTYPE : the type of the meteorogical event. To be tidy, values should come from a list defined by the National Weather Service Instruction.
        - BGN_DATE : Date of the beginning of the event
        - FATALITIES : number of dead persons due to the event
        - INJURIES : number of injured persons due to the event
        - PROPDMG : Cost of the property damages due to the event
        - PROPDMGEXP : Magnitude in which PROPDMG is expressed ($ million, $ billion,...)
        - CROPDMG : Cost of the crop damages due to the event
        - CROPDMGEXP : Magnitude in which CROPDMG is expressed ($ million, $ billion,...)
```{r Select useful data}
# Keep only data used in this report
storm_data <- select(storm_data, REFNUM, STATE, STATENAME, EVTYPE, BGN_DATE, FATALITIES, INJURIES, PROPDMG, PROPDMGEXP, CROPDMG, CROPDMGEXP)
```
\  
\  

## Cleaning data

### Cleaning (`BGN_DATE`) : Date of the beginning of en event

Convert `BGN_DATE` to date type, format `Y-m-d`
```{r Cleaning BGN_DATE, message = FALSE}
storm_data$BGN_DATE <- trimws(as.character(storm_data$BGN_DATE))
storm_data$BGN_DATE <- ymd(parse_date_time(storm_data$BGN_DATE, orders = c("mdY HMS")))
```
\  
\  

### Cleaning magnitude for damage amounts (`PROPDMGEXP`) and (`CROPDMGEXP`)

According to documentation, magnitude unit should be `B`, `M` or `K` for billions, millions and thousands.

There is `r nrow(subset(storm_data, !(PROPDMGEXP %in% list("B","b","M","m","K","k","H","h",""," "))))` dummy values for `PROPDMGEXP` (Property damages). We assume to set them to NA.

```{r Cleaning magnitude Properpty}
storm_data$PROPDMGEXP <- ifelse(
        !(storm_data$PROPDMGEXP %in% list("B","b","M","m","K","k","H","h")),
        NA,
        toupper(storm_data$PROPDMGEXP)
)
```
\  
\  

Same case with `r nrow(subset(storm_data, !(CROPDMGEXP %in% list("B","b","M","m","K","k","H","h",""," "))))` dummy values for `CROPDMGEXP`

```{r Cleaning magnitude Crop}
storm_data$CROPDMGEXP <- ifelse(
        !(trimws(storm_data$CROPDMGEXP) %in% list("B","b","M","m","K","k","H","h")),
        NA,
        toupper(trimws(storm_data$CROPDMGEXP))
)
```
\  
\  

### Cleaning (`EVTYPE`), the type of event

A great cleaning seems to be useful, since a lot of values of event types **are not listed** in the normalized data coming from National Weather Service (NWS).
We have to clean some typos and some texts freely composed.

```{r First cleaning}
# Trim space and upper EVTYPE
storm_data$EVTYPE <- trimws(toupper(storm_data$EVTYPE))

# Replace `WINDS` occurrence by `WIND` in `storm_data$EVTYPE`
storm_data$EVTYPE <- str_replace_all(storm_data$EVTYPE, "WINDS", "WIND")
```

To ease and automate the cleaning, we created a new separate CSV file [`EVTYPE.csv`](https://github.com/affagard/RepData_PeerAssessment2/blob/master/data/EVTYPE.csv) containing a regular list of type of events based on the Storm Data Documentation. This list is shorter than the NWS list.
For instance, we assume to merge Tornado with Hurricane/Typhoon in a single type : Tornado/Hurricane/Typhoon, since the difference between them is only a scientific meteorlogical difference about how they form, which is not the aim with this report. They have the same physical impact on human and economy.

The CSV file `EVTYPE.csv` may be dowloaded [here](https://github.com/affagard/RepData_PeerAssessment2/blob/master/data/EVTYPE.csv)

**Main events we assume to merge**

 - `Tornado` with `Hurricane/Typhoon`
 - `Excessive Heat` with `Heat`
 - `Extreme Cold / Wind Chill` with `Cold / Wind Chill`
 - `Flash flood`and `Coastal flood` with `Flood`
 - All events occurring `Dry` with `Drought`
 - All events occurring `Tide` with `Astronomical Low Tide`


```{r Regular Event types, message=FALSE, warning=FALSE}

regular_event_types <- read.csv("data/EVTYPE.csv")

# Normalize to upper case
regular_event_types$EVTYPE <- toupper(regular_event_types$EVTYPE)

# Set column EVTYPE.1 in storm_data with regular event types, set NA if EVTYPE is not originally regular
storm_data$EVTYPE.1 <- ifelse(storm_data$EVTYPE %in% regular_event_types$EVTYPE,storm_data$EVTYPE, NA)

# Subset a new dataframe from storm_data with no regular event types
storm_data.1 <- subset(storm_data, is.na(EVTYPE.1))
storm_data.1$EVTYPE <- as.factor(storm_data.1$EVTYPE)
storm_data.1 <- group_by(storm_data.1,EVTYPE)
```

To correct as better as possible typos and freely composed events, we decided to compose a list of keywords from which occurences in events enable to match the well labelled event in the regular list.
The keyword list is a CSV file names [`EVTYPE_KEY.csv`](https://github.com/affagard/RepData_PeerAssessment2/blob/master/data/EVTYPE_KEY.csv) that could be dowloaded [here](https://github.com/affagard/RepData_PeerAssessment2/blob/master/data/EVTYPE_KEY.csv).

At the end, unmatched event types are set to **`NA`**, so that these records will be ignored in this study.

```{r Cleaning with keywords, cache=TRUE}

# A list of keywords defined in a specific CSV file to clean typos and mismatched occurences 
evtype_keys <- read.csv ("data/EVTYPE_KEY.csv", header=TRUE, sep = ",", dec=".")
evtype_keys$KEY <- toupper(evtype_keys$KEY)
evtype_keys$EVTYPE <- toupper(evtype_keys$EVTYPE)

# Loop in the list of keywords to find and replace well labelled event
for(key in evtype_keys$KEY) {
        
        # Subset records containing the keyword in EVTYPE
        storm_data.2 <- subset(storm_data.1, str_detect(storm_data.1$EVTYPE, key, negate = FALSE))
        
        # Apply correction on EVTYPE in storm_data
        storm_data$EVTYPE <- ifelse(
                storm_data$REFNUM %in% storm_data.2$REFNUM, 
                as.character(evtype_keys$EVTYPE[evtype_keys$KEY==key]),
                storm_data$EVTYPE
        )
        
        # Also apply correction on EVTYPE in storm_data.1
        storm_data$EVTYPE.1 <- ifelse(
                (storm_data$REFNUM %in% storm_data.2$REFNUM),
                storm_data$EVTYPE,
                storm_data$EVTYPE.1
        )
        # And refresh storm_data.1 with removing modified record
        storm_data.1 <- subset(storm_data, is.na(EVTYPE.1))
        storm_data.1$EVTYPE <- as.factor(storm_data.1$EVTYPE)
        
}


# After corrections, refresh the column EVTYPE.1 of storm_data
storm_data$EVTYPE.1 <- ifelse(storm_data$EVTYPE %in% regular_event_types$EVTYPE,storm_data$EVTYPE, NA)
# Finally move EVTYPE.1 to EVTYPE
storm_data$EVTYPE <- storm_data$EVTYPE.1

```
\  
\  
\  
\  

### Filter data to keep only the modern years (since 1993)

Data are spread over years since 1950. Last records are in 2011.
While analyzng data, we noticed a great difference of number of records before and after 1993. Furthermore, it seems that event types are more detailled since this same year of 1993. These two facts surely mean that new methods and new digital tools of recording are in use since this time.

- **Before 1993** : mean of **`r as.integer(nrow(subset(storm_data, BGN_DATE < "1993-01-01"))/(1992-1950))`** records per year with **`r length(levels(as.factor(subset(storm_data, BGN_DATE < "1993-01-01")$EVTYPE)))`** different event types

- **After 1993** : mean of **`r as.integer(nrow(subset(storm_data, BGN_DATE >= "1993-01-01"))/(2011-1993))`** records per year with **`r length(levels(as.factor(subset(storm_data, BGN_DATE >= "1993-01-01")$EVTYPE)))`** different event types

As some new types of events are now more detailed since 1993, some of types were surely previously mixed. We therefore assume that, for this report, we only take into account the data after 1993, in order to have a real view of recurrences for each event type.

**So, the period of our study is from 1993 to 2011 (18 years)**
```{r Begin date}
storm_data <- subset(storm_data, BGN_DATE >= "1993-01-01")
storm_data <- ungroup(storm_data)
```
\  
\  
\  
\  
\  
\  

## Results 

### Most harmful events with respect the population health globally in United States

We wish here display the most harmful events with population health globally in United States. Further we wish display the same result but detailed by state.

First we sort event types by both numbers of fatalities and injuries. We consider that the most harmful is done **first** by the greatest sum of **fatalities** and **secondly** by the greatest sum of **injuries**. We will figure out apart fatalities and injuries in the final plot.

According to this, we build the dataframe to plot.
```{r Data most harmful}
# Dataframe to the most harmful event types regarding fatalities
storm_data.fatalities <- select(storm_data, EVTYPE, FATALITIES)
storm_data.fatalities$type <- "fatalities"
storm_data.fatalities <- subset(storm_data.fatalities, FATALITIES > 0 & !is.na(EVTYPE))
colnames(storm_data.fatalities) <- c("event_type","nb_damages","type")

# Dataframe to the most harmful event types regarding injuries
storm_data.injuries <- select(storm_data, EVTYPE, INJURIES)
storm_data.injuries$type <- "injuries"
storm_data.injuries <- subset(storm_data.injuries, INJURIES > 0 & !is.na(EVTYPE))
colnames(storm_data.injuries) <- c("event_type","nb_damages","type")

# Bind fatalities and injuries with types of harmful
# Set a dataframe concerning the first plot : most harmful event types with respect to population health
storm_data.harmful <- rbind(storm_data.fatalities,storm_data.injuries)
```

#### Most harmful event types with population health from 1993 to 2011

```{r First Plot, fig.height=10, fig.width=15, message=FALSE, cache=TRUE}
g <- ggplot(
        data = storm_data.harmful,
        aes(x = reorder(event_type, nb_damages*(type=="fatalities"), sum, na.rm=TRUE), y = nb_damages, fill = type, group = desc(type))
)
g <- g + theme_bw() + ggtitle("Most harmful event types with population health from 1993 to 2011")
g <- g + theme(legend.position = "top") + labs( x = "Event types", y = element_blank(), fill=element_blank())
g <- g + geom_bar(stat = "identity", position="stack")
g <- g + coord_flip(xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
g <- g + scale_y_continuous(breaks=seq(0,30000,1000), expand = c(0,100), position = "right", limits = c(0,NA))
print(g)
```
\  
\  
\  
\  
\  
\  
\  
\  
\  
\  
\  


Nevertheless, we noticed while analyzing data that the most harmful event types are very different across United States. So we decide to publish the same results dÃ©tailed by states while comparing between the most affected states. To focus on the most harmful, we decide in followings to point out **only fatalities**.

```{r Fatalities per Sate}
# With STATES, only FATALITIES
# Dataframe of storm data limited to the n-first most harmful event types regarding fatalities
storm_data.fatalities.state <- select(storm_data, STATENAME, EVTYPE, FATALITIES)
storm_data.fatalities.state$type <- "fatalities"
storm_data.fatalities.state <- subset(storm_data.fatalities.state, FATALITIES > 0)
colnames(storm_data.fatalities.state) <- c("state","event_type","nb_damages","type")

fatalities.state <- aggregate(
                x = as.integer(storm_data.fatalities.state$nb_damages), 
                by = list(storm_data.fatalities.state$event_type, storm_data.fatalities.state$state),
                FUN=sum,
                na.rm=TRUE
                )
colnames(fatalities.state) <- c("event_type","state","nb_damages")
fatalities.state <- arrange(fatalities.state,desc(nb_damages))
fatalities.state <- subset(fatalities.state,nb_damages > 10)
```

#### Most harmful event types with population health from 1993 to 2011 **per US state** (only fatalities)

```{r fig.width=10, fig.height=25, cache=TRUE}
g <- ggplot(
        data = fatalities.state,
        aes(x = reorder(paste(event_type,"in",state),nb_damages), y = nb_damages, fill = event_type, group = event_type)
)
g <- g + theme_bw() + ggtitle("Fatalities per event type and per state from 1993 to 2011")
g <- g + theme(legend.position = c(0.7,0.9)) + labs( x = element_blank(), y = "Fatalities", fill = "Event types")
g <- g + geom_bar(stat = "identity") + coord_flip(xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
g <- g + scale_y_continuous(breaks=seq(0,max(fatalities.state$nb_damages)+50,50), position = "right", limits = c(0,NA), expand = c(0,10))
print(g)

```
\  
\  
\  
\  
\  
\  
\  
\  
\  
\  
\  
\  


### Greatest economic consequences


```{r}
# Different units (millions, billions, ...) are used so we need to normalize data amounts of material damages in dollars

# Add a coefficient column for property damages in $
storm_data$PROPDMGCOEF <- 1
storm_data$PROPDMGCOEF <- if_else(!is.na(storm_data$PROPDMGEXP) & storm_data$PROPDMGEXP == "K", 1000, storm_data$PROPDMGCOEF)
storm_data$PROPDMGCOEF <- if_else(!is.na(storm_data$PROPDMGEXP) & storm_data$PROPDMGEXP == "M", 1000000, storm_data$PROPDMGCOEF)
storm_data$PROPDMGCOEF <- if_else(!is.na(storm_data$PROPDMGEXP) & storm_data$PROPDMGEXP == "B", 1000000000, storm_data$PROPDMGCOEF)

# Add a coefficient column for crop damages in $
storm_data$CROPDMGCOEF <- 1
storm_data$CROPDMGCOEF <- if_else(!is.na(storm_data$CROPDMGEXP) & storm_data$CROPDMGEXP == "K", 1000, storm_data$CROPDMGCOEF)
storm_data$CROPDMGCOEF <- if_else(!is.na(storm_data$CROPDMGEXP) & storm_data$CROPDMGEXP == "M", 1000000, storm_data$CROPDMGCOEF)
storm_data$CROPDMGCOEF <- if_else(!is.na(storm_data$CROPDMGEXP) & storm_data$CROPDMGEXP == "B", 1000000000, storm_data$CROPDMGCOEF)

# Add a column to calculate property and crop damages in $
storm_data$prop_damages_in_doll <- coalesce(storm_data$PROPDMGCOEF*storm_data$PROPDMG, 0)
storm_data$crop_damages_in_doll <- coalesce(storm_data$CROPDMGCOEF*storm_data$CROPDMG, 0)

# Aggregate strom_data to matrial_damages by sum of property and crop damages in dollars
material_damages <- aggregate(
                x = list(storm_data$prop_damages_in_doll, storm_data$crop_damages_in_doll),
                by = list(storm_data$EVTYPE), FUN=sum, na.rm=TRUE
                )
colnames(material_damages) <- c('event_type', 'prop_damages_in_doll', 'crop_damages_in_doll')

# Create a column with total damages in dollars
material_damages$total_in_doll <- coalesce(material_damages$prop_damages_in_doll,0) + coalesce(material_damages$crop_damages_in_doll,0)

# Factorize event_type
material_damages$event_type <- as.factor(material_damages$event_type)

# Order by total descending
material_damages <- material_damages[with(material_damages, order(-total_in_doll)), ]

# Add a rank column for most expensive
material_damages$rank <- 1:length(material_damages$event_type)

# Finally the dataframe of the 20 first most expensive event types
final_events_material_damages <- select(material_damages, event_type, rank, total_in_doll)

# Create a dataframe of storm data limited to the 20 first most expensive event types regarding property
storm_data.prop <- select(storm_data, EVTYPE, prop_damages_in_doll)
storm_data.prop$type <- "property"
storm_data.prop <- subset(storm_data.prop, prop_damages_in_doll > 0 & !is.na(EVTYPE))
colnames(storm_data.prop) <- c("event_type","damages_in_doll","type")

# Create a dataframe of storm data limited to the 20 first most expensive event types regarding crop
storm_data.crop <- select(storm_data, EVTYPE, crop_damages_in_doll)
storm_data.crop$type <- "crop"
storm_data.crop <- subset(storm_data.crop, crop_damages_in_doll > 0 & !is.na(EVTYPE))
colnames(storm_data.crop) <- c("event_type","damages_in_doll","type")

# Bind property and crop damages for the 20 first most expensive event types
# Set the dataframe dor the second plot : event types that have greatest economic consequences
storm_data.material.damages <- rbind(storm_data.prop,storm_data.crop)
storm_data.material.damages <- merge(storm_data.material.damages, final_events_material_damages, by = "event_type")
```

#### Material damages in $ Billions cumulative from 1993 to 2011

```{r fig.height=8, fig.width=10, cache=TRUE}

g <- ggplot(
        data = storm_data.material.damages,
        aes(x = reorder(event_type, total_in_doll), y = damages_in_doll/1000000000, fill = type)
)
g <- g + theme_bw() + theme()
g <- g + theme(legend.position = "bottom") + labs( x = "Event types", y = "Material damages in $ Billions cumulative from 1993 to 2011", fill = element_blank())
g <- g + geom_bar(stat = "identity")
g <- g + coord_flip(xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
g <- g + scale_y_continuous(breaks=seq(0,max(storm_data.material.damages$damages_in_doll/1000000000)+200,5), position = "right", limits = c(0,NA), expand = c(0, 1))

print(g)

```
\  
\  
\  
\  

## Conclusion

- The most harmful event types with respect of the population health are in ordering : Heat, Tornadoes/Hurricanes/Typhoons, Floods, Lightnings, Rip currents, Winds and Thunderstorms
- But harmfulness relies of geographical location and differs in U.S. states. So a closer analysis implying location is required to enable local decisions.
- Ranking for economic consequences may be very different from ranking of harmfulness with population.

        - Tornadoes/Hurricanes/Typhoons, Floods, Hight winds and Thunderstorms are up for the two rankings.
        - Heat, Lightning, Rip current are up for harmfulness with population, but they are less for economic consequences.
        - Drought is low consequence on harmfulness with population, but is pretty up for economic consequences.

- In order to make decisions, we recommend to go further with analyzing the evolution over the last years of the frequencies of severe meteorological events.


